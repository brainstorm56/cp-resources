1. (a) Kadane's Algo for calculating maxsum only (without indexes)


    int maxSubArray(vector<int>& nums) {
        int curMax = 0, maxTillNow = INT_MIN;
        for(auto c : nums)
            curMax = max(c, curMax + c),
            maxTillNow = max(maxTillNow, curMax);
        return maxTillNow;
    }


1. (b) Kadane's Algo for calculating maxsum with indexes;


void maxSubArraySum(int a[], int size)
{
	int max_so_far = INT_MIN, max_ending_here = 0,
		start = 0, end = 0, s = 0;

	for (int i = 0; i < size; i++) {
		max_ending_here += a[i];

		if (max_so_far < max_ending_here) {
			max_so_far = max_ending_here;
			start = s;
			end = i;
		}
		if (max_ending_here < 0) {
			max_ending_here = 0;
			s = i + 1;
		}
	}
	cout << "Maximum contiguous sum is " << max_so_far
		<< endl;
	cout << "Starting index " << start << endl
		<< "Ending index " << end << endl;
}



2. Count time


auto start = high_resolution_clock::now();
    for (int i = 0; i < N; ++i)
        v1.push_back(i);
    auto stop = high_resolution_clock::now();
    auto duration = duration_cast<microseconds>(stop - start);
 
    cout << "Method I took " << duration.count() << " microseconds\n"
    
    
3. Binary Search
    
    
    ll l = 1; ll r = max;
    while (r - l > 1)
    {
        ll mid = l + ((r - l) / 2);

        ll ans = 0;
       // calculate ans (may be in a loop)
       // t is the value being searched
        if (ans >= t)
        {
            r = mid;
        }
        else
        {
            l = mid;
        }
    }
    // Now l and r both can be answer, So check for both of them individually if they satisfy the condition given or not;
    //return l or r according to above line



4. prime numbers up to N (Sieve of eratosthenes)

	const int N = 0;
	vector<int> prime(N+5,1);
	vector<int>primes;
void sieve(){
   	prime[0] = prime[1] = 0;
	for (int i = 2; i * i <= N; i++) {
    		if (prime[i]) {
        for (int j = i * i; j <= N; j += i)
            prime[j] = 0;
   			      }
					}
	for(int i=2;i<=N;i++)
	{
   	      if(prime[i]){primes.push_back(i);}
	}
     }
     

5. Prime factors of many numbers optimally (using optimization in sieve)


	const int N = 0;
	vector<int> prime(N+5,1);	
void sieve() {
    prime[0] = prime[1] = 0;
    for (int i = 2; i * i <= N; i++) {
        if (prime[i] == 1) {
            for (int j = i * i; j <= N; j += i)
                prime[j] = i;
        }
    }
    for (int i = 2; i <= N; i++)
    {
        if (prime[i] == 1) {prime[i] = i;}
    }
}
void primefactors(ll number, vector<int>&v)
{
    while (number >= 2)
    {
        int val = prime[number];
        v.push_back(val);
        while (value % val == 0)
        {
            number = number / val;
        }
    }
}
	

6.  Intersection of two intervals both sides included

	Two intervals [l,r] & [left, right]
	if (left <= r && l <= right)
	 {
		l = max(left, l);
		r = min(right, r);
	}
	else
	{
		Null
	}
	
7.  Sqrt function takes way more time for a double or floating point than integer value.

8. Fenwick trees implementation

	const int N = 1e5 + 10;
	int bit[N] {0};
	
	void update(ll i, ll x) {
	  for (; i < N; i += (i & -i))
	    bit[i] += x;
	}
	
	ll Sum(ll i) {
	  int ans = 0;
	  for (; i > 0; i -= (i & -i))
	    ans += bit[i];
	  return ans;
	}
     a. first update all elements of the array using update function. 
     b. update function adds the argument provided to it not replace it.
     c. its written on one based indexing. 
     d. for sum from l to r sum = Sum(r) - Sum(l-1);


9.  Disjoint set 


    class DisjointSet {
  vector<int>rank, parent, size;
public:
  DisjointSet(int n) {
    rank.resize(n + 1, 0);
    parent.resize(n + 1);
    size.resize(n + 1);
    for (int i = 0; i <= n; i++) {
      parent[i] = i;
      size[i] = 1;
    }
  }
  int findUPar(int node) {
    if (node == parent[node])
      return node;
    return parent[node] = findUPar(parent[node]);
  }

  void unionByRank(int u, int v) {
    int ulp_u = findUPar(u);
    int ulp_v = findUPar(v);
    if (ulp_u == ulp_v) return;
    if (rank[ulp_u] < rank[ulp_v]) {
      parent[ulp_u] = ulp_v;
    }
    else if (rank[ulp_v] < rank[ulp_u])
    {
      parent[ulp_v] = ulp_u;
    }
    else
    {
      parent[ulp_v] = ulp_u;
      rank[ulp_u] ++;
    }
  }
  void unionBySize(int u, int v) {
    int ulp_u = findUPar(u);
    int ulp_v = findUPar(v);
    if (ulp_u == ulp_v) return;
    if (size[ulp_u] < size[ulp_v]) {
      parent[ulp_u] = ulp_v;
      size[ulp_v] += size[ulp_u];
    }
    else
    {
      parent[ulp_v] = ulp_u;
      size[ulp_u] += size[ulp_v];
    }
  }
};


10. Bitwise Operations

bool powerOfTwo(ll x){ return x && !(x&(x-1)); }
bool chkset(ll x, ll k) { return x&(1<<k); }
void setbit(ll &x, ll k) { x = x|(1<<k); }
void unsetbit(ll &x, ll k) { x = x&~(1<<k); }
void togglebit(ll &x, ll k) { x = x^(1<<k); }
ll noOfSetBits(ll x) { return __builtin_popcountll(x); }


11. bitwsise xor
suppose: a^b^c^d^e^f^g =0
Observation: Choose any of the a,b,c,d,e,f,g => for example b,f,g left are (a,c,d,e) => then b^f^g = a^c^d^e.

12. Count the number of nodes below a node in a tree(implemented by undirected graph in a vector<long long>adj[] structure

ll dfs(ll ind, vector<ll>adj[], ll dist[], ll par)
{
	ll cnt = 0;
	for (auto it : adj[ind])
	{
		if (it != par)
		{
			cnt += dfs(it, adj, dist, ind);
		}
	}
	dist[ind] = cnt;
	return 1 + cnt;
}
